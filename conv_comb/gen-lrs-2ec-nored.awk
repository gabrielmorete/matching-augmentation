# 29jan21, 16jan21, 7jan21, 18jul06
# awk program to write out input-file for LRS (H-representation), for zero-one cost 2EC (FAP)
# usage: awk -f this_file_name input_file > output_file
#
# variables correspond to NONzero-edges and zero-edges correspond to constants (NOT vars)
#
# IMPORTANT: edit output_file and move the last line to the start, to replace line "0 0 rational ..."

# based on:
# awk program to write out LP in gurobi/cplex format, for zero-one cost 2EC (FAP)

# given list of edges i,j and
#	list of zero-edges i,j,
# generates all nontrivial cuts S
# writes out a 0/1 row for each S, entry for i,j is 1 if i,j in \delta(S)

# 16jan21: eliminate redundant cut constraints: if cut has >=2 zero-edges, then skip (don't write constraint)

BEGIN	{
	print "* input file for LRS (H-representation), generated by awk program gen-lrs-2ec-nored"
	start = 1
	arcindx = 0
	numarcs = 0
	numvars = 0
	objnonzedge = 1
	}

#	write comment lines ('*' for LRS) with leading '*'
/^\*/	{ printf("*"); print $0 }

/^Nnodes/       { Nnodes = $2 }

/^edges/ { for (i=1; i< NF; i++) {
		j = i+1;
		split( $j, arcarray, ",");
		tail[arcindx + i] = arcarray[1];
		head[arcindx + i] = arcarray[2];
		objcoeff[arcindx + i] = objnonzedge;
		}

	# debug:
	printf("* ")
	for (i=arcindx + 1; i< arcindx + NF; i++) {
	printf(" %d:%d,%d ", i, tail[i], head[i] ) }
	printf("\n")

	numarcs += (NF - 1) ;
	arcindx = numarcs ;

	numvars += (NF - 1) ;
	}

/^zero-edges/ { for (i=1; i< NF; i++) {
		j = i+1;
		split( $j, arcarray, ",");
		tail[arcindx + i] = arcarray[1];
		head[arcindx + i] = arcarray[2];
		objcoeff[arcindx + i] = 0 ;
		}

	# debug:
	printf("* zero-edges")
	for (i=arcindx + 1; i< arcindx + NF; i++) {
	printf(" %d:%d,%d ", i, tail[i], head[i] ) }
	printf("\n")

	numarcs += (NF - 1) ;
	arcindx = numarcs ;

	}

#===== =====

END	{

	if (start == 1) {
		start = 0

#       header lines for .lrsin file
        print "H-representation"
        print "begin"
        printf("%d %d rational (***IMPORTANT: replace this line by the last line***)\n", 0, 0)
	}

#=====
	# cut constraints for LRS
	# generate bitvector for all sets excl. 1 (revise: see Wilf, chap.2)

	{
	done = 0
	while (done != 1) { # main loop - add 1 to bitvec to get next set

	for (i=2; i<= Nnodes; i++) {
		if ( bitarray[i] == 0 ) { bitarray[i] = 1; break }
		bitarray[i] = 0; }
	if (i > Nnodes) { # now, bitarray is all zero, so quit main loop
			done = 1; break
			}

	j = 1;
	for (i=1; i<= Nnodes; i++) {
		if (bitarray[i] == 1) setarray[j++] = i ;
		}
	Setsize = j-1 ;


	# 16jan21
	# eliminate redundant cut constraints: if cut has >=2 zero-edges, then skip (don't write constraint)
	numzedgesincut = 0
	for (i=1; i<= numarcs ; i++) {
		tbit = 0; # assume tail not in set
		hbit = 0; # assume head not in set
		for (j=1; j<= Setsize; j++) {
		if ( tail[i] == setarray[j] ) tbit = 1;
		if ( head[i] == setarray[j] ) hbit = 1;
			}
		if ( ((tbit==0) && (hbit==1)) || ((tbit==1) && (hbit==0)) ) {
			if (objcoeff[i] == 0) numzedgesincut++
		}
	}

	#16jan21 added "if ..." around code-block that writes cut constraint
	if (numzedgesincut <= 1) {

#	debug for LRS o/p:
#	printf("DEBUG: shore of cut is {i,node(i)} \n")
#	for (i=1; i<= Setsize; i++) {
#	printf(" %d:{%d} ", i, setarray[i] ) }
#	printf("\n")

        #for LRS, RHS is -k ... as in ... x(\d{in}(S)) >= k
	{ if (numzedgesincut == 0) {printf("-2 ");} else {printf("-1 ")} }

#	numarcswritten = 0

	for (i=1; i<= numarcs ; i++) {
		tbit = 0; # assume tail not in set
		hbit = 0; # assume head not in set
		for (j=1; j<= Setsize; j++) {
		if ( tail[i] == setarray[j] ) tbit = 1;
		if ( head[i] == setarray[j] ) hbit = 1;
			}
		if (objcoeff[i] == 1) {
		if ( ((tbit==0) && (hbit==1)) || ((tbit==1) && (hbit==0)) )
			printf(" 1 ")
		else
			printf(" 0 ");
		}
#
#			numarcswritten++
#			if ((numarcswritten%8)==0) printf("\n")
	}

	numconstr++
	printf("\n")
	} #end-if

	for (i=1; i<= Setsize; i++) { setarray[i] = 0 };

	} # end main loop
	}
#===== end codeblock: cut constraints for LRS

	{
        # for each variable (NONzero-edge) write nonneg constr for LRS, upperbound (=1) constr for LRS

	for (i=1; i<= numarcs ; i++) {
	if (objcoeff[i] == 1) {
	# nonneg constr, for LRS, RHS is 0
	printf(" 0 ")
	for (j=1; j<= numarcs ; j++) {
		if (objcoeff[j] == 1) {
		if (i==j) {printf(" 1 ")} else {printf(" 0 ")}; }
		}
	printf("\n")
	# upperbound constr, for LRS, RHS is -1
	printf(" 1 ")
	for (j=1; j<= numarcs ; j++) {
		if (objcoeff[j] == 1) {
		if (i==j) {printf(" -1 ")} else {printf(" 0 ")}; }
		}
	printf("\n")
	} # end if
	} # end for


	# for LRS, this should go to start of file
	printf("%d %d rational\n", numconstr + (2 * numvars), 1+numvars)
        }
#END
	}

